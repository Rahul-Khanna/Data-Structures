{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Rahul Khanna\
rk2658\
Programming Assignment 2\
\
How to Run Code When In Directory With Files:\
javac *.java\
java program2 "EXPRESSION"\
\
Class Descriptions:\
\
ExpressionTree:\
\
Creates an expression tree from a string from the command line. Breaks the string down by the space character and stores the individual parts of the String into ENodes. The ENodes are stored into a stack, which holds the information of the tree. Every time an operator is seen the top two ENodes from the stack are popped and are connected to the operator node through the left/right links. The operator node is then pushed onto the stack. At the end, all nodes are connected to a single operator and the tree in finished. The printing of the trees is pretty simple just a recursive algorithm that goes through each branch of tree and essentially just puts together the left and right branches at every stage. The placement of the operator is what really differentiates the three different prints. \
\
Stack:\
\
An array implementation of the Stack Abstract Type. Elements can be pushed or popped. Also if the array runs out of size, its size can expand.\
\
ENode:\
\
Just a node for a binary tree, adapted for an expression tree.\
\
program2:\
\
The tester class for the expression tree class. Takes in the input from the command line and gives it to the expression tree class, which then builds the expression tree and prints it out in three different ways.}